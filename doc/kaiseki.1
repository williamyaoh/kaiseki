.\" Automatically generated by Pandoc 1.19.2.1
.\"
.TH "kaiseki" "1"
.hy
.SH NAME
.PP
kaiseki \- unintrusive literate programming preprocessor
.SH SYNOPSIS
.PP
kaiseki [options] [<file> ...]
.PP
kaiseki (\-\-help | \-h)
.PP
kaiseki \-\-version
.SH OPTIONS
.TP
.B \-c, \-\-comment \f[I]COMMENT\f[]
Add comments to tangled output file showing which file and line number
each section came from.
Prefix each comment with the given comment syntax.
.RS
.RE
.TP
.B \-i, \-\-ignore\-errors
Exit normally and squelch all error messages that occur during
processing (by default, kaiseki will exit abnormally if any errors are
found).
Not recommended.
.RS
.RE
.SH DESCRIPTION
.PP
\f[B]kaiseki\f[] aims to be a simple\-to\-use, humble preprocessor.
\f[B]kaiseki\f[] believes in the worth of literate programming, of
writing programs for people to read first.
To that end, it follows these principles:
.PP
\f[B]Literate programming should be plaintext\f[]
.PP
Too many literate programming systems get hung up on typesetting code
into a beautiful book for everyone to read.
But you can\[aq]t open up a PDF in an editor and start hacking on the
code, and that\[aq]s the best way for someone to learn a codebase.
\f[B]kaiseki\f[] only takes plaintext as input, and only spits out
plaintext as output.
\f[B]kaiseki\f[] source files are just normal source code, same as the
ones you edit every day in your editor.
And that means you can learn the code the same way you always do: by
poking it and seeing what it does.
.PP
\f[B]Literate programming should be layered\f[]
.PP
Many literate programming systems aim to be monolithic.
The output is a book, or a research paper.
All the code goes into a single file, and there\[aq]s no way to figure
out where anything is.
You have to read the whole thing in order to understand the structure.
Flouting the wisdom of using the filesystem as a hierarchy, of naming
files so that you know what their contents are, does not lead to good
code.
.PP
There\[aq]s no good way to work \f[I]across\f[] files.
For many literate programming systems, breaking things across files is a
nightmare.
The structure becomes jumbled and confused; instead of elucidating the
structure of the program, it gets hidden underneath a mess of included
files and tags.
Wasn\[aq]t this the problem literate programming was meant to solve?
.PP
\f[B]kaiseki\f[] instead encourages building the program in layers.
Instead of defining independent blocks which get cobbled together in the
\f[I]real\f[] program, \f[B]kaiseki\f[] \f[I]starts\f[] from a working
program and adds things into it.
First, a working, compiling program with nothing in it.
Each layer then \f[I]inserts\f[] things into the previous to add on to
it, each one continuing to produce something that works.
This better facilitates learning the code; someone coming into the
codebase can go upwards, layer by layer, gradually figuring out each
piece before moving on to the next one, instead of being dumped
headfirst into the codebase.
.PP
\f[B]Literate programming should be simple\f[]
.PP
You shouldn\[aq]t have to learn LaTeX or memorize a dozen arcane
commands merely to write a program that\[aq]s readable.
\f[B]kaiseki\f[] has only \f[B]4\f[] commands, easily understood:
\f[B]insert\f[], \f[B]label\f[], \f[B]before\f[], and \f[B]after\f[].
That\[aq]s it!
.SH SYNTAX
.PP
\f[B]kaiseki\f[] believes in the longevity of plaintext.
As such, input to \f[B]kaiseki\f[] is simply normal source code files,
with one catch: any line containing "\f[B]anchors\f[]" is interpreted as
a special directive to \f[B]kaiseki\f[].
.PP
An \f[B]anchor\f[] looks like: \f[C]##[<command>[(<arg>)]]\f[]
.PP
Take the following C code:
.IP
.nf
\f[C]
/*\ ##[label(Includes)]\ */
/*\ ##[label(Forward\ Declarations)]\ */

int\ main(int\ argc,\ char*\ argv[])\ {
\ \ \ \ /*\ ##[label(Initialization)]\ */

\ \ \ \ return\ 0;
}

/*\ ##[after(Includes)]\ */

#include\ <stdio.h>
#include\ <stdlib.h>

/*\ ##[before(Initialization)]\ */

char*\ buf\ =\ malloc(sizeof(char)\ *\ 1024);

/*\ ##[insert]\ */
/*\ Now\ we\[aq]re\ back\ to\ adding\ code\ after\ `main()`.\ */

void\ foo()\ {
\ \ \ \ printf("Hello!");
}
\f[]
.fi
.PP
The output would (approximately) be:
.IP
.nf
\f[C]
#include\ <stdio.h>
#include\ <stdlib.h>

int\ main(int\ argc,\ char*\ argv[])\ {
\ \ \ \ char*\ buf\ =\ malloc(sizeof(char)\ *\ 1024);

\ \ \ \ return\ 0;
}

void\ foo()\ {
\ \ \ \ printf("Hello!");
}
\f[]
.fi
.SH COMMANDS
.PP
There are \f[B]4\f[] commands that can be used in \f[B]anchors\f[].
.PP
\f[B]insert\f[]
.PP
Don\[aq]t do a rearrangement on the following block of lines.
Simply place them as\-is at the end of the output.
.PP
\f[B]label\f[] <\f[I]arg\f[]>
.PP
Create a new insertion point wherever lines are currently being
inserted.
Can be used inside the "scope" of a \f[C]##[before(<label>)]\f[] or a
\f[C]##[after(<label>)]\f[].
.PP
An intuitive way to think about it is that inserted lines will "expand"
outward from the position of the label in the text.
.PP
\f[B]before\f[] <\f[I]arg\f[]>
.PP
Insert the following block of lines \f[I]before\f[] the given label.
.PP
If multiple blocks get inserted before a given label, the \f[I]first\f[]
block seen and processed will be the \f[I]last\f[] to appear in the
output.
.PP
\f[B]after\f[] <\f[I]arg\f[]>
.PP
Insert the following block of lines \f[I]after\f[] the given label.
.PP
If multiple blocks get inserted after a given label, the \f[I]first\f[]
block seen and processed will be the \f[I]first\f[] to appear in the
output.
.SH SEE ALSO
.PP
\f[B]noweb\f[](1) Another literate programming tool.
Suffers from many of the problems discussed above with literate
programming.
